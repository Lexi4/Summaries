МДК 02.02 Разработка и защита баз данных
Андриянова Элла Максовна
** пары
---------------------------------------------------------
1 пара - 09.09.2019
	Должны досдать практические работы за прошлый год, должны сделать курсовую работу, а для начала выбрать её предметную область.

	Проектирование и разработка баз данных

	Основы SQL:
Рост количества данных,Ю необходимость их хранения и обработк, привели к тому, что возникла потребность в создании стандартного языка баз данных, который мог бы функционировать в многочисленных компьютерных системах различных видов. Действительно, с его помощью пользователи могут манипулировать данными независимор от того, работают ли они на персональном компьютере, сетевой рабочей станции или универсальной ЭВМ.
	Стандарт на язык SQL был выпущен американским национальным институтом стандартов (ANSI) в 1986 году, а в 1987, ISO приняла его в качестве международного. Нынешний стандарт SQL известен под названием SQL/92
	Одним из языков, появившихся в результате разработки реляционной модели данных, является язык SQL (Structured Querry Language). Под реализацией языка SQL понимается программныый продукт SQL.
	Основные категории команд языка SQL:
DDL - язык определения данных
DML - язык манипулирования данныъ
DQL - язык запросов
DCL - язык управления данными
команды администрирования данных
команды управления транзакциями
	Определение структур базы данных(DDL)
	Язык определения данных(data definition language, ddl) позволяет создавать и изменять структуру обьектов базы данных, например создавать и удалять таблицы
	Основными командами языка DDL являются следующие:
		CREATE TABLE - создать таблицу
		ALTER TABLE - изменить таблицу
		DROP TABLE - удалить таблицу

		CREATE INDEX - создать индекс
		ALTER INDEX - изменить индекс
		DROP INDEX - убрать индекс

	Манипулирование данными(DML)
		INSERT - вставить новую строку
		UPDATE - изменить существующую
		DELETE - удалить строку

	Выборка данных(DQL)
		SELECT - выборка данных, гы
	
	Язык управления данными(DCL - Data Control Language)
	Управление доступом к информации:
		GRANT - Дать доступ
		REVOKE - Отозвать доступ

	Команды администрирования данных:
С помощью команд администрирования данных пользователь осуществляет контроль за выполняемыми действиями и анализирует операции базы данных. Они также могут оказаться полезными при анализе производительности системы. Не следует путать администрирование данных с администрированием базы данных, которое представляет собой общее управление базой данных и подразумевает использование команд всех уровней.
	
	Команды управления транзакциями:
		COMMIT - Внести изменения
		ROLLBACK - Откатить 
		SAVEPOINT - Создать точку сохранения
		SET TRANSACTION - Назначить транзакцию

	Преимущества языка SQL - является основой многих СУБД, т.к отвечает за физическое структурирование и запись данных на диск, а также за чтение данных с диска, позволяет принимать SQL-запросы от других компонентов СУБД и пользовательских приложений. Таким образом, SQL - мощный инструмент, который обеспечивает пользователям, программам и вычислительным системам доступ к информации содержащейся в реляционных БД.
Достоинства:
	1. Стандартность
	2. Независимость от конкретных СУБД.
	3. Возможность переноса с одной вычислительной системы на другую
	4. Реляционная основа языка, табличная структура реляционной БД хорошо понятна, а потому язык прост для изучения.
	5. Возможность программного доступа к БД.
	6. Возможность интерактивных запросов обеспечивающая немедленный доступ
	7. Обеспечение различного представления данных - с помощью SQL можно представить такую структуру данных, что тот или иной пользователь будет видеть различные их представления. Кроме того данные из разных частей БД могут быть скомбинированы и представлены в виде одной простой таблицы, а значит представления пригодны длоя усиления защиты БД и её настройки под конкретные приспособленности БД к изменяющимся требованиям предметной области.
	8. Возможность динамического изменения и расширения структуры БД.
	
	Любой язык работы с БД должен предоставлять следующие возможности:
	1. Создавать базы данных и таблицы с полным описанием их структуры
	2. Выполнять основные операции манипулирования данными, в частности, вставку, модификацию и удаление данных из таблиц.
	3. Выполнять простые и сложные запросы осуществляющие преобразование данных.

ВАЖНАЯ ИНФОРМАЦИЯ, КУРСОВИК, КУРСАЧ
=========================================================	
	Защита курсовика в феврале месяце. Сдаём все курсовики в Январе. 
	Пояснительная записка и разработанная БД под практическое применение. 
	Должна быть форма в которую заносится информация.
Пользователь не должен видеть таблицу, а исключительно форму ввода и форму запроса.	
=========================================================

	Запись SQL-операторов. Идентификаторы языка SQL предназначены для обозначения обьектов в базе данных и являются именами таблиц представлений столбцов и обьектов базы данных. В качестве обозначения идентификаторов могут использоваться буквы английского алфавита, как строчные так и прописные, десятичные цифры т.е 0-9 и нижние подчёркивание "_". К обозначениям идентификаторов предьявляются следующие требования. 
	1. Длина идентификатора не превышает 128 символов. 
	2. Первый символ идентификатора обязательно буква. 
	3. Не допускаются пробелы
	
	Выглядит запись идентификатора следующим образом:
<идентификатор>::=<буква> {<буква>|<цифра>}[..n]
=========================================================
Символ |			Обозначение
=========================================================	
  ::=  |	Равно по определению
---------------------------------------------------------
   |   |  Необходимость выбора одного из нескольких 			  |   приведенных значений 	
---------------------------------------------------------
 <...> |  Описанная с помощью метаязыка структура языка
---------------------------------------------------------
 {...} |  Обязательный выбор некоторой конструкции из 		  |  списка
---------------------------------------------------------
 [...] |  Необязательный выбор некоторой конструкции из    	  |  списка
---------------------------------------------------------
 [...n]| Необязательная возможность повторения    		  | конструкции от нуля до нескольких раз
---------------------------------------------------------

	Описание учебной базы.

	В качестве примера будет использоваться небольшая БД, отражающая процесс поставки и продажи некоторого товара постоянным клиентам.
	Значит есть две сущности клиент и товар. Они находятся в отношении многие ко многим.
	 Реляционная база данных не допускает отношений "многие ко многим", чтобы это устранить необходимо ввести новую сущность. Назовём её сделка. Тогда соотношение сущности товар-сделка в конкретной сделке будет находится в отношении "многие к одному", также отношение сделка-клиент находятся в взаимосвязи "Один к многим". Таким образом мы избавились от соотношения "многие к многим". 
	Определим атрибуты и свяжем их с сущностями.
	1. Товар - характеристика, название, тип, цена, сорт
	2. Клиент - имя, отчество, фамилия, фирма, город, телефон.(ФИО нельзя делать одним полем)
	3. Сделка - дата, количество проданного товара.
	
	Важным этапом в создании БД является определение атрибутов которые однозначно определяют каждый экземпляр сущности, т.е выявление первичных ключей.
	Поэтому вводим первичные ключи:
	1. Товар - код_товара(может быть и артикул товара)
	2. Клиент - код_клиента(например паспорт, ИНН итд)
	3. Сделка - код_сделки
	
	Далее надо установить связи между таблицами. ОДин покупатель может неоднократно покупать товары. Поэтому между таблицами Клиент и Сделка имеется связь "один-ко-многим" по полю Код_клиента.
	Каждый покупатель может приобрести несколько различных товаров, поэтому между таблицами Товар и Сделка имеется связь "один-ко-многим" по полю "код товара"
	Теперь нужно создать связи между таблицами самой базы данных. КодКлиента и КодТовара являются внешними ключами в таблице Сделка, как-бы отсылая на записи с ними.
	
---------------	---------------     ----------------	
|	Товар    |    |    Сделка    |    |    Клиент     |
--------------     ---------------     ----------------
|PK |КодТовара|    |PK |КодСделки |    |PK |КодКлиента |
--------------     ---------------     ----------------
|   |Название |    |   |Количество|    |   |Фамилия    |
|   |Тип      |<---|   |Дата      |--->|   |Имя        |
|   |Сорт     |    |FK1|КодТовара |    |   |Отчество   |
|   |Цена     |    |FK2|КодКлиента|    |   |Фирма      |
|   |Остаток  |    ----------------    |   |ГородКлиент|
|   |ГородТов |                        |   |Телефон    |
---------------                        -----------------
		 Рис 1. Пример Структуры базы данных

Типы данных SQL
	В языке SQL имеется шесть скалярных типов данных, определенных стандартом. Их краткое описание представлено в таблице:
=========================================================
     Тип данных     |             Обьявления
=========================================================
 Символьный	     | CHAR|VARCHAR
 Битовый		     | BIT|BIT VARYING
 Точные числа	     | NUMERIC|DECIMAL|INTEGER|SMALLINT
 Округлённые числа | FLOAT|REAL|DOUBLE PRECISION
 Дата\Время	     | DATE|TIME|TIMESTAMP
 Интервал		     | INTERVAL
=========================================================	
	Символьные данные состоят из последовательности символов разрешённых в СУБД набор символов. Обычно используют ASCII, EBCDIC. Для определения используется формат:
	<символьный тип>::={CHARACTER [VARYING][Длина]|[CHAR|VARCHAR][Длина]}
	
	Битовый тип данных используется для определения битовых строк, т.е последовательности двоичных цифр.
Определяются данные при помощи следующего формата:
	<битовый тип>::=BIT[VARYING][длина]

	Точные числа(int), масштаб указывает количество дробных десятичных разрядов числа. Определяется форматом:
	<фиксированный_тип>::={NUMERIC[точность[масштаб]]{DECIMAL|DEC}[точность[,масштаб]]|{INTEGER|INT}|SMALLINT}

	Типы NUMERIC и DECIMAL предназначены для хранения чисел в десятичном формате. По умолчанию длина дробной части равна нулю, а INTEGER(INT)используется для хранения больших положительных или отрицательных целых чисел. Тип SMALLINT - сокращенная версия INT
	
	Округлённые числа(float).Применяются обычно в научной нотации, их нельзя представить в компьютере достаточно точно, но можно точность выбрать.
	<вещественный_тип>::={FLOAT[точность]|REAL|DOUBLE PRECISION}
	
	Символ % - все последующие символы
	Символ _ - один символ
	NULL - отсутствие значения
	is not null - есть какое-то значение
	order by - сортировка по
	asc - по возростанию
	desc - по убыванию
	
	Фраза order by должна быть последней в операторе select.

select клиент.фирма, клиент.фамилия 
from клиент 
order by клиент.фирма, клиент.фамилия desc

Арифметическая выборка:

Рассчитать общую стоимость каждой сделки. Этот запрос использует расчёт результирующих столбцов на основе арифметических выражений

SELECT товар.название, товар.цена, сделка.количество,
товар.цена*сделка.количество AS стоимость 
FROM товар INNER JOIN сделка
ON товар.кодтовара=сделка.кодтовара	
	
	Получить список фирм с указанием фамилии и инициалов клиентов:

SELECT фирма, фамилия+" "+left(имя,1)+"."+left(отчество,1)+"."AS ФИО FROM Клиент
	
	Получить список товаров с указанием года и месяца продажи:
	Select товар.название, year(сделка.дата) as год, 	month(сделка.дата) as месяц from товар inner join сделка on товар.кодтовара=сделка.кодтовара
	
	COUNT(выражение) - выдаёт количество.
	MIN/MAX() - минимальное максимальное
	AVG() - среднее
	SUM() - сумма
	
	Примеры, определить первое по алфавиту название товара:
	Select min(товар.название) as min_название
	from товар.
	
	Предложение group by

Существует 2 типа подзапросов:
	1. Скалярный
	2. Табличный
	
	Использование подзапросов, возвращающих единичное значение: Пример. Определить дату продажи максимальной партии товара.
	Select Дата, количество
	From Сделка
	Where Количество=(Select max(количество)from сделка)

	Пример. Определить даты сделок, превысившых по количеству товара среднее значение и указать для этих сделок превышение над средним уровнем.
	Select Дата, количество,
	Количество-(select avg(количество) from сделка)
	as Превышение from сделка where количество >
	(select avg(количество) from сделка)


	Пример. Определить клиентов, в сделках которых количество товара отличается от максимального не более чем на 10%:
	Select клиент.фамилия,
	сделка.количество
	from клиент inner join Сделка
	on клиент.кодклиента=
	сделка.кодклиента
	where сделка.количество >=0.9*(select max	(сделка.количество)from сделка)
	
	
	Пример. Определить даты, когда среднее количество проданного за день товара оказалось больше 20 единиц.
	Select сделка.дата, avg(сделка.количество) as
	среднее_за_день
	from сделка
	group by сделка.дата
	having avg(сделка.количество)>20
	
	
	Операторы IN и NOT IN
IN используется для сравнения некоторого значения со списком значений, при этом проверяется, входит ли значение в предоставленный список или сравниваемое значение. Есть в списке, или нету в списке. Гыг

	DISTINCT - Только уникальные значения.(без повторов тобишь.)
	
	Пример. Определить фирмы, покупающие товары местного производства
	Select distinct клиент.фирма, клиент.городклиента, товар.городтовара
	from товар inner join
	(клиент inner join сделка 
	on клиент.кодклиента=сделка.кодклиента) 
	on товар.кодтовара=сделка.кодтовара 
	where клиент.городклиента=товар.городтовара
	
	Определить фирмы, которые покупают только товары, произведенные в своёмм городе и никакие другие
	select distinct клиент.фирма,
	клиент.городклиента,
	товар.городтовара
	from товар inner join
	(клиент inner join сделка
	on клиент.кодтовара=сделка.кодклиента)
	on товар.кодтовара-сделка.кодтовара
	where клиент.городклиента not in 
	(select distinct клиент.городклиента
	from	товар inner join
	(клиент inner join сделка
	on клиент.кодклиента=сделка.кодклиента)
	on товар.кодтовара=сделка.кодтовара
	where клиент.городклиента<>
	товар.городтовара) 	 
	
 Использование ключевых слов any и all
	all - условие сравнения считается выполненным, когда выполняется для всех значений в результирующем столбце подзапроса
	any - условие выполнгено хотябы для одного условия.
	Пример. Определить клиентов, совершивших сделки с максимальным количеством товара.
	select клиент.фамилия, сделка.количество
	from клиент inner join сделка
	on клиент.кодклиента=сделка.кодклиента
	where сделка.количества>=ALL(Select количество from сделка)
	

	Пример найти фирму, которая приобрела товаров на самую большую сумму.
	select клиент.фирма,
	sum(товар.цена*сделка.количество)
	as общ_стоимость
	from товар inner join
	(клиент inner joun сделка
	on клиент.кодклиента=сделка.кодклиента)
	on товар.кодклиента=сделка.кодтовара
	group by клиент.фирма
	having sum(товар.цена*сделка.количество)>=
	all(select sum(товар.цена*сделка.количество)
	from товар inner join сделка
	on товар.кодтовара=сделка.кодтовара
	group by сделка.кодклиента)
	
	
	Вложенный подзапрос подсчитывает общуюб стоимость покупок каждого клиента. Внешний подзапрос также подсчитывае тобщую стоимость покупок каждого клиенгта и определяет теъ, для кого эта сумма, по сравнению с другими покупателями, оказалась больше или точно такойже.
	Пример. Найти фирмы, в сделкаъ которых количество товара превышает такой-же показатель хотябы в одной сделке клиентов из Самары.
	Select клиент.фирма, сделка.количество
	from клиент inner join сделка
	on клиент.кодклиента=сделка.кодклиента
	where сделка.количество>
	any(select сделка.количество 
	from клиент inner join сделка 
	on клиент.кодклиента=сделка.кодклиента
	where клиент.городклиента='Самара')
	
	Использование операций exists и not exists
Они предназначены для использования со спецзапросами. Выдают значение true-false.
Exists - присутствует хотябы одна строка
Not exists - не присутствует ничего
	Пример. Определить список имеющихся на складе товаров.
	Select Название
	from товар
	where exists(select кодтовара
	from склад
	where товар.кодтовара=склад.кодтовара)

	Пример. Определить список отсутствующих на складе товаров.
	Select Название
	from товар
	where not exists(select кодтовара
	from склад
	where товар.кодтовара=склад.кодтовара)
	
	Пример. Добавить в таблицу товар новую запись
	insert into Товар(Название,Тип,Цена)
	values('Славянский','шоколад',12)
	
	Если столбты таблицы указаны в полном составе и в томже порядке, то values можно не писать.
	
	Вторая форма оператора Insert с параметром Select позволяет скопировать множество строк из одной таблицы в другую.
	Пример. Добавить в итоговую таблицу сведения об общей сумме ежемесячных продаж каждого наименования товара.
	Insert into Итог
	(Название, Месяц, Стоимость)
	Select Товар.Название, month(сделка.дата)
	as Месяц, sum(товар.цена*сделка.количество)
	as стоимость
	from товар inner join сделка
	on Товар.кодтовара=сделка.кодтовара
	group by товар.название, month(сделка.дата)
	
	Запрос удаления:
	<оператор_удаления>::=Delete
	from <имя_таблицы>[where <условие_отбора>]
	
	Пример. Удалить все прошлогодние сделки.
	Delete from сделка where year(дата.сделка)=year	(getdate())-1
	
Update и в африке update
	
Целостность данных
	Выполнение операторов модификации данных в таблицах БД. Insert, Delete, Update. Операторы могут привести к нарушению целостности данных и их корректности, т.е к потере их достоверности и непротиворечивости

	Ссылочная целостность
Указанное ограничение касается ключей. 
	1. Один ко многим - сущность неизменна
	2. Один к одному - 
	3. Многие ко многим - 

	Следующая проблема при организации поддержки ссылочкой целостности при выполнении операций модификации данных в базе, тут возможно следующее.
	Удаление строки происходит из дочерней таблицы. Никаких нарушений ссылочной целостности не происходит.
	Обновление ключа в строке дочерней таблицы.Этот случай


MODIFY - изменение параметров файлов и групп файлов.
Remove - удалить файлы или группы файлов
ReadOnly - группа файлов используется только для чтения
ReadWrite - в группе файлов разрешаются изменения
Default - указанная группа файлов принимается по умолчанию.

Удаление базы данных: 
DROP DATABASE имя базы данных [,...n]

Создание таблицы 
	После создания общей структуры БД можно приступить к созданию таблиц, которые представляют собой отношений, входящие в состав проекта БД.
	Таблица - основной обьект для хранения информации в реляционной БД. Она состоит из содержащих данные строк и столбцов, занимает в базе данных физическое пространство и может быть постоянной или временной.
	Поле, также называемое в базе данных столбцом, является частью таблицы, за которой закреплен определённый тип данных. Каждая таблица базы данных должна содержать хотябы один столбец. Строка данных - это запись в таблице БД, она включает поля, содержащие данные из одной записи таблицы.
	Базовый синтаксис оператора создания таблицы имеет следующий вид:
	<определение_таблицы>::=
	CREATE TABLE имя_таблицы
	(имя_столбца тип_данных
	[NULL | NOT NULL][,...n])
	
	Пример. Добавить в таблицу Клиент поле для номера расчётного счёта.
	Alter table Клиент ADD рас_счёт char(20)
	
	Пример удаления:
	Drop table имя_таблицы
	
	Индексы предоставляют собой структуру позволяющую получать ускоренный доступ к строкам таблицы на основе значений одного или более столбцов.
	
	Создание функций:
	1. Multi-statement возвращают значение типа Table
	2. Inline содержат всего одну команду select
	3. scalar возвращают скалярное значение
		<определение>::=
		{create|alter} function [владелец] имя_функции
		([{@имя_параметра скаляр_тип_данных
		[=default]}[,...n]])
		returns скаляр_тип_данных
		[with {encryption|schemabinding}
		[,...n]]
		[as]
		begin
		<тело_функции>
		return скаляр_выражение
		end

	Пример. Использование вложенных процедур. Создать процедуру для определения общего количества товаров, приобретённых фирмой, в которой работает заданный сотрудник.
	Затем создадим процедуру, подсчитывающую общее количества товаров, который закуплен интерисующей нас фирмой.
	CREATE PROC my_proc8
	 @fam VARCHAR(20),
	 @kol INT OUTPUT
	AS
	DECLARE @firm VARCHAR(20)
	EXEC my_proc7 @fam,@firm OUTPUT
	SELECT @kol=Sum(Сделка.Количество)
	FROM Клиент INNER JOIN Сделка
	 Клиент.КодКлиента=Сделка.КодКлиента
	GROUP BY Клиент.Фирма
	 HAVING Клиент.Фирма=@firm
	 
	Вызов процедуры осуществляется с помощью команды:
	DECLARE @k INT
	EXEC my_proc8 'Иванов', @k OUTPUT
	SELECT @k
	
Тригеры - особый инструмент SQL-сервера, используемый для поддержания целостности данных в БД. С помощью ограничений целостности, правил и значений по умолчанию не всегда можно добиться нужного уровня функциональности. Часто требуется реализовать сложные алгоритмы проверки данных, гарантирующие их достоверность и реальность.
Кроме того, иногда необходимо отслеживать изменения значений таблицы, чтобы нужным образом изменить связанные данные. Триггеры можно расматривать как своего рода фильтры, вступающие в действие после выполнения всех операций. Триггер представляет собой специальный тип хранимых процедур, запускаемых сервером автоматически при попытке изменения данных в таблицах, с которыми триггеры связаны. Каждый триггер привязывается к конкретной таблице. Все производимые им модификации данных рассматриваются как транзакция. Создаёт триггер только владелец БД. Это ограничение позволяет избежать случайного изменения структуры таблиц, способов связи с ними других обьектов и т.п.
	Триггер представляет собой весьма полезное и в то же время опасное средство. Так, при неправильной логике его работы можно легко уничтожить целую БД, поэтому триггеры необходимо очень тщательно отлаживать.
	С помощью них достигаются следующие цели:
	- Проверка корректности введённых данных и выполнение сложных ограничений целостности данных, которые трудно, если вообще возможно поддерживать с помощью ограничений целостности, установленных для таблицы
	- Выдача таких предупреждений, напоминающих о необходимости выполнения некоторых действий при обновлении таблицы, реализованном определённым образом
	- Накопление аудиторской информации посредством фиксации сведений о внесённых изменениях и тех лицах, которые их выполнили.
	- Поддержка репликации
	